Некоторые технические подробности создания LGLZ
-----------------------------------------------

	Что побудило меня написать данную программу(LGLZ)?

	Ответ прост - любопытство.Меня давно интересует сжатие данных, и в
один из дней года два назад я решил посмотреть, как реализуется сжатие в
популярной программе DIET v1.0.(Во избежание кривотолков скажу, что
дизассемблированием самой программы я не занимался, а лишь просматривал и
анализировал дамп программ, сжатых DIET-ом, что, надеюсь, законом об авторских
правах не возбраняется). После выяснения алгоритма сжатия меня удивила его
неоптимальность. Поясню на конкретном примере:

	В исходном файле встретилась цепочка
	FF FF FF FF FF FF FF FF

	DIET сжимает ее примерно так (не вдаваясь в подробности реализации):
	1 FF		- символ FF
	1 FF		- -"-
	0 2 FE		- 2 символа со смещением -2
	0 4 FC		- 4 символа со смещением -4
	
	хотя, не меняя суть алгоритма распаковки, можно написать так:
	
	1 FF		- символ FF
	0 7 FF		- 7 символов со смещением -1

	что, как оказалось в дальнейшем, делает PKLITE


	
	Написав первоначальный вариант алгоритма, реализующего данный принцип,
я решил пойти дальше и написал двух(или трех)проходный алгоритм поиска самой
длинной строки.Принцип примерно такой:

	1.i=0.Мы находимся на позиции i в исходном файле.

	2.Ищем самую длинную цепочку совпадения, начиная с позиции
	   i-$2000 (длина ее=len,смещение в окне=ofs).

	3.Если len=1, либо достигнута максимальная длина,переходим к пункту 12
	(в версии 1.04c:
	если len>=x,также идем к пункту 12
	s0 - x=2,s1 - x=3,s2 - x=4,s3 - x=5,s4 - x=7,s5 - x=10,s6 - x=25,
	s7 - x=50,s8 - x=100,s9 - x=бесконечность)

	4.Переходим на позицию i+len

	5.Ищем самую длинную цепочку совпадения, начиная с позиции
	   i+len-$2000 (длина ее=len1,смещение в окне=ofs1).

	6.Запоминаем количество бит, необходимое для представления найденных
	   двух цепочек(bits).

	7.Возвращаемся на позицию i+1.

	8.Ищем цепочку длиной len+len1-1, начиная с позиции i+1-$2000 
	   (длина ее=len2,смещение в окне=ofs2).

	9.Если она не найдена,переходим к пункту 12

	10.Подсчитываем количество бит, необходимое для представления 
	   цепочек 1+inbuf[i] и len2+ofs2 (bits1).

	11.Если bits1<bits,len=1

	12.Посылаем в выходной поток len и смещение(либо символ из входного
	   потока,если len=1).

	13.i=i+len

	14.Если не конец файла, преходим к пункту 2

	В результате, естественно, скорость упаковки ощутимо замедляется
(примерно в 1.5-2 раза), что несущественно, поскольку пакуется файл 1 раз,
зато достигается более оптимальное сжатие (алгоритм и, естественно, скорость
самораспаковки при этом не изменяется).

	Написана программа на чрезвычайно уродливой смеси TP 7.0 и TASM 1.02,
поэтому исходники в ближайшем будущем доступны публике не будут.

	Пришлось еще немного покорпеть над более быстрым алгоритмом поиска
строки (вариант "в лоб" был медленнее нынешнего в 5-6 раз) и уменьшением
модуля самораспаковки, в результате чего и появилась предлагаемая Вам
программа.

	В версии 1.04c добавлен ключ -sn, позволяющий значительно (при s0
более чем в 2 раза) ускорить упаковку при небольшой потере степени сжатия.
	Возможно, в следующей версии (если будет на нее время), я увеличу
окно поиска до 8-16 кБ (вместо 4-х, правда это потребует дополнительной
памяти и замедлит упаковку).
